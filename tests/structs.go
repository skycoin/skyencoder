// Package tests has tests for autogenerated structs
package tests

/* Demo structs for test generation */

type Coins uint64

type Hash [20]byte

type DynamicStruct struct {
	Foo []string
	Bar int32
	Baz string
}

type StaticStruct struct {
	A    byte
	B    int32
	Hash Hash
}

type DemoStruct struct {
	Uint8                  uint8
	Uint16                 uint16
	Uint32                 uint32
	Uint64                 uint64
	Int8                   int8
	Int16                  int16
	Int32                  int32
	Int64                  int64
	Float32                float32
	Float64                float64
	Byte                   byte
	String                 string
	DynamicStruct          DynamicStruct
	StaticStruct           StaticStruct
	NamedByteArray         Hash
	NamedBasicType         Coins
	DynamicKeyMap          map[string]uint16
	DynamicElemMap         map[uint16]string
	DynamicMap             map[string]string
	DynamicNestedMap       map[string][10][]string
	DynamicArrayKeyMap     map[[10]string]uint32
	StaticByteArrayKeyMap  map[Hash]uint16
	StaticByteArrayElemMap map[uint16]Hash
	StaticStructMap        map[int32]StaticStruct
	SetMap                 map[int32]struct{}
	DynamicStringArray     [10]string
	StaticBasicArray       [10]int64
	StaticStructArray      [10]StaticStruct
	DynamicSlice           []string
	StaticSlice            []StaticStruct

	Uint8Slice                  []uint8
	Uint16Slice                 []uint16
	Uint32Slice                 []uint32
	Uint64Slice                 []uint64
	Int8Slice                   []int8
	Int16Slice                  []int16
	Int32Slice                  []int32
	Int64Slice                  []int64
	ByteSlice                   []byte
	StringSlice                 []string
	DynamicStructSlice          []DynamicStruct
	StaticStructSlice           []StaticStruct
	NamedByteArraySlice         []Hash
	NamedBasicTypeSlice         []Coins
	DynamicKeyMapSlice          []map[string]uint16
	DynamicElemMapSlice         []map[uint16]string
	DynamicMapSlice             []map[string]string
	DynamicNestedMapSlice       []map[string][10][]string
	DynamicArrayKeyMapSlice     []map[[10]string]uint32
	StaticByteArrayKeyMapSlice  []map[Hash]uint16
	StaticByteArrayElemMapSlice []map[uint16]Hash
	StaticStructMapSlice        []map[int32]StaticStruct
	SetMapSlice                 []map[int32]struct{}
	DynamicStringArraySlice     [][10]string
	StaticBasicArraySlice       [][10]int64
	StaticStructArraySlice      [][10]StaticStruct
	DynamicSliceSlice           [][]string
	StaticSliceSlice            [][]StaticStruct

	ignored    uint64 `enc:"-"`
	unexported uint64

	StringMaxLen    string          `enc:",maxlen=4"`
	MapMaxLen       map[int64]uint8 `enc:",maxlen=5"`
	ByteSliceMaxLen []byte          `enc:",maxlen=6"`
	SliceMaxLen     []int64         `enc:",maxlen=7"`
}

type DemoStructOmitEmpty struct {
	Int32     int32
	OmitEmpty []byte `enc:",omitempty"`
}

/* nested byte array */

type DemoStructNestedBytes struct {
	Objects []DemoStructNestedBytesInner
}

type DemoStructNestedBytesInner struct {
	Data []byte
}

/* maxlen tag tests */

type MaxLenStringStruct1 struct {
	Foo string `enc:",maxlen=3"`
}

type MaxLenStringStruct2 struct {
	Foo string `enc:",maxlen=4"`
}

type MaxLenAllStruct1 struct {
	Foo string           `enc:",maxlen=3"`
	Bar []int64          `enc:",maxlen=3"`
	Baz map[uint64]int64 `enc:",maxlen=3"`
}

type MaxLenAllStruct2 struct {
	Foo string           `enc:",maxlen=4"`
	Bar []int64          `enc:",maxlen=4"`
	Baz map[uint64]int64 `enc:",maxlen=4"`
}

type MaxLenNestedSliceStruct1 struct {
	Foo []MaxLenStringStruct1
}

type MaxLenNestedSliceStruct2 struct {
	Foo []MaxLenStringStruct2
}

type MaxLenNestedMapKeyStruct1 struct {
	Foo map[MaxLenStringStruct1]int64
}

type MaxLenNestedMapKeyStruct2 struct {
	Foo map[MaxLenStringStruct2]int64
}

type MaxLenNestedMapValueStruct1 struct {
	Foo map[int64]MaxLenStringStruct1
}

type MaxLenNestedMapValueStruct2 struct {
	Foo map[int64]MaxLenStringStruct2
}

type OnlyOmitEmptyStruct struct {
	Extra []byte `enc:",omitempty"`
}

type OmitEmptyStruct struct {
	Foo   string
	Extra []byte `enc:",omitempty"`
}

type OmitEmptyMaxLenStruct1 struct {
	Foo   string
	Extra []byte `enc:",omitempty,maxlen=3"`
}

type OmitEmptyMaxLenStruct2 struct {
	Foo   string
	Extra []byte `enc:",maxlen=4,omitempty"`
}
